-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" SCHEMA extensions;

-- Wallets we are actively tracking or have discovered
CREATE TABLE tracked_wallets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    address TEXT NOT NULL UNIQUE,
    alias TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    tags TEXT[],
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Memecoins we have seen in trades
CREATE TABLE tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    address TEXT NOT NULL UNIQUE,
    symbol TEXT,
    name TEXT,
    metadata JSONB,
    last_seen TIMESTAMPTZ DEFAULT NOW()
);

-- Log of every relevant transaction by a tracked whale
CREATE TABLE whale_trades (
    id BIGSERIAL PRIMARY KEY,
    wallet_address TEXT NOT NULL REFERENCES tracked_wallets(address),
    coin_address TEXT NOT NULL REFERENCES tokens(address),
    trade_type TEXT NOT NULL CHECK (trade_type IN ('BUY', 'SELL')),
    sol_amount NUMERIC,
    token_amount NUMERIC,
    transaction_hash TEXT NOT NULL UNIQUE,
    trade_timestamp TIMESTAMPTZ NOT NULL
);

-- Create indexes for performance
CREATE INDEX idx_whale_trades_wallet_timestamp ON whale_trades (wallet_address, trade_timestamp DESC);
CREATE INDEX idx_whale_trades_coin_timestamp ON whale_trades (coin_address, trade_timestamp DESC);
-- Add index on trade_timestamp for time-series queries (replacing hypertable functionality)
CREATE INDEX idx_whale_trades_timestamp ON whale_trades (trade_timestamp DESC);

-- Signals generated by the processor
CREATE TABLE trade_signals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    coin_address TEXT NOT NULL REFERENCES tokens(address),
    status TEXT NOT NULL DEFAULT 'OPEN' CHECK (status IN ('OPEN', 'EXECUTED', 'EXPIRED')),
    trigger_reason TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    closed_at TIMESTAMPTZ
);

-- Our own trades, paper or live
CREATE TABLE portfolio_trades (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    signal_id UUID REFERENCES trade_signals(id),
    trade_mode TEXT NOT NULL CHECK (trade_mode IN ('PAPER', 'LIVE')),
    coin_address TEXT NOT NULL REFERENCES tokens(address),
    status TEXT NOT NULL DEFAULT 'OPEN' CHECK (status IN ('OPEN', 'PARTIALLY_CLOSED', 'CLOSED')),
    entry_price NUMERIC,
    high_water_mark_price NUMERIC,
    entry_timestamp TIMESTAMPTZ,
    exit_price NUMERIC,
    exit_timestamp TIMESTAMPTZ,
    pnl_usd NUMERIC,
    exit_reason TEXT
);

-- Configuration table for signal generation
CREATE TABLE signal_config (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    min_whales INTEGER DEFAULT 3,
    time_window_hours INTEGER DEFAULT 1,
    min_trade_amount_sol NUMERIC DEFAULT 0.5,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Insert default configuration
INSERT INTO signal_config (min_whales, time_window_hours, min_trade_amount_sol) 
VALUES (3, 1, 0.5);

-- Function to check for multi-whale signals
CREATE OR REPLACE FUNCTION check_for_signals()
RETURNS TRIGGER AS $$
DECLARE
    config_rec RECORD;
    whale_count INTEGER;
    signal_exists BOOLEAN;
    whale_list TEXT[];
BEGIN
    -- Get the latest configuration
    SELECT * INTO config_rec FROM signal_config ORDER BY created_at DESC LIMIT 1;
    
    -- Check if we already have an open signal for this coin
    SELECT EXISTS(
        SELECT 1 FROM trade_signals 
        WHERE coin_address = NEW.coin_address 
        AND status = 'OPEN'
    ) INTO signal_exists;
    
    -- If signal already exists, skip
    IF signal_exists THEN
        RETURN NEW;
    END IF;
    
    -- Count unique whales that bought this coin in the time window
    SELECT COUNT(DISTINCT wallet_address), ARRAY_AGG(DISTINCT wallet_address) 
    INTO whale_count, whale_list
    FROM whale_trades
    WHERE coin_address = NEW.coin_address
    AND trade_type = 'BUY'
    AND trade_timestamp >= NOW() - INTERVAL '1 hour' * config_rec.time_window_hours
    AND (sol_amount IS NULL OR sol_amount >= config_rec.min_trade_amount_sol);
    
    -- If threshold is met, create a signal
    IF whale_count >= config_rec.min_whales THEN
        INSERT INTO trade_signals (
            coin_address,
            status,
            trigger_reason,
            metadata
        ) VALUES (
            NEW.coin_address,
            'OPEN',
            whale_count || ' whales bought within ' || config_rec.time_window_hours || ' hour(s)',
            jsonb_build_object(
                'whale_addresses', whale_list,
                'whale_count', whale_count,
                'confidence', LEAST(whale_count / 5.0, 1.0)
            )
        );
        
        -- Notify real-time subscribers
        PERFORM pg_notify('new_signal', json_build_object(
            'coin_address', NEW.coin_address,
            'whale_count', whale_count,
            'whale_addresses', whale_list
        )::text);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger for signal detection
CREATE TRIGGER trigger_check_signals
AFTER INSERT ON whale_trades
FOR EACH ROW
WHEN (NEW.trade_type = 'BUY')
EXECUTE FUNCTION check_for_signals();

-- Enable Row Level Security
ALTER TABLE tracked_wallets ENABLE ROW LEVEL SECURITY;
ALTER TABLE tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE whale_trades ENABLE ROW LEVEL SECURITY;
ALTER TABLE trade_signals ENABLE ROW LEVEL SECURITY;
ALTER TABLE portfolio_trades ENABLE ROW LEVEL SECURITY;

-- Create policies for service access (adjust based on your auth strategy)
-- For now, we'll create permissive policies for development
CREATE POLICY "Service full access" ON tracked_wallets FOR ALL USING (true);
CREATE POLICY "Service full access" ON tokens FOR ALL USING (true);
CREATE POLICY "Service full access" ON whale_trades FOR ALL USING (true);
CREATE POLICY "Service full access" ON trade_signals FOR ALL USING (true);
CREATE POLICY "Service full access" ON portfolio_trades FOR ALL USING (true);