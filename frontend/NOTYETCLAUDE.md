# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## MCP Servers to use
Use context7 to search for documentation on Supabase, Neon, Helius, Solana and everything that you have trouble with getting things to work. Read more docs!
Use the Supabase mcp server to get info on tables, views, functions, etc. You may also update table schemas if needed.
Use the Neon mcp server to get info on tables, views, functions, etc. You may also update table schemas if needed.

## Project Overview
This is a frontend for a Solana trading app.


This is the Sonar Platform - a whale wallet intelligence system for Solana that monitors high-net-worth wallet activity to identify early memecoin investment opportunities. The system detects coordinated buying patterns and generates trading signals.

## Architecture

The platform uses a **microservices architecture** with the following core components:

1. **whale-watcher**: Real-time blockchain monitoring service using Helius WebSocket API
2. **notifier**: Multi-channel alert system (Telegram, Discord, CLI) using Supabase Realtime
3. **signal-processor**: PostgreSQL trigger function that detects multi-whale buying patterns
4. **CLI**: Command-line interface for wallet management, signal viewing, and portfolio tracking

The system is **event-driven** with Supabase (PostgreSQL + TimescaleDB) as the central data store. Signal detection happens atomically at the database level through triggers for Phase 1, with plans to evolve to BullMQ/Redis message queues in later phases.

## Development Commands

### Project-wide commands (from root):
```bash
npm install          # Install all dependencies
npm run build        # Build all packages with Turbo
npm run dev          # Run all services in dev mode
npm run typecheck    # Type check all packages
npm run lint         # Lint all packages (when configured)
npm run clean        # Clean all build artifacts
```

### Service-specific commands:
```bash
# Whale Watcher Service
cd services/whale-watcher
npm run dev          # Run with auto-reload
npm start            # Run production build

# Notifier Service  
cd services/notifier
npm run dev          # Run with auto-reload
npm start            # Run production build

# CLI Tool
cd cli
npm run build        # Build the CLI
npm link             # Make 'sonar' command globally available
sonar wallet list    # Example CLI usage
```

### Database Setup

1. Create a Supabase project
2. Run `scripts/supabase-schema.sql` in Supabase SQL editor
3. Configure environment variables from `.env.example`

## Key Technical Decisions

- **TypeScript** with strict mode for all services
- **Monorepo** using npm workspaces and Turbo for build orchestration
- **Helius SDK** for parsed transaction WebSockets (critical for simplifying blockchain data ingestion)
- **Supabase Realtime** for push-based notifications instead of polling
- **TimescaleDB** hypertables for optimized time-series queries on whale trades
- **Database triggers** for atomic signal generation in Phase 1

## Database Schema

Core tables with foreign key relationships:
- `tracked_wallets` → Referenced by `whale_trades`
- `tokens` → Referenced by `whale_trades`, `trade_signals`, `portfolio_trades`  
- `whale_trades` → TimescaleDB hypertable partitioned by timestamp
- `trade_signals` → Generated by trigger when threshold met
- `portfolio_trades` → Paper/live trades linked to signals

## Environment Variables

Required:
- `SUPABASE_URL` - Your Supabase project URL
- `SUPABASE_ANON_KEY` - Supabase anonymous key
- `HELIUS_API_KEY` - For blockchain data access

Optional:
- `TELEGRAM_BOT_TOKEN` & `TELEGRAM_CHAT_ID` - For Telegram alerts
- `DISCORD_WEBHOOK_URL` - For Discord alerts

## Future Phases

The architecture is designed for phased evolution:
- **Phase 2**: Automated trading via Jupiter SDK and bot APIs
- **Phase 3**: Advanced exit strategies with trailing take-profit
- **Phase 4**: Whale discovery engine using DEX scraping
- **Phase 5**: Web dashboard and public API

## Code Quality Rules (CRITICAL - READ EVERY TIME)

1. **Clean up after yourself**: When removing functionality, delete ALL related code - don't leave orphaned variables, imports, or dead code
2. **Understand the architecture first**: Before making changes, understand how the existing system works (HTMX lifecycle, Alpine.js components, etc.)
3. **Work with the framework, not against it**: Don't use hacks like global flags to fight framework behavior - embrace the intended patterns
4. **HTMX-specific rules**:
   - **This is NOT a SPA - keep it simple**
   - Components will re-initialize when fragments are swapped - this is normal
   - Use caching strategies instead of trying to prevent re-initialization
   - Don't use global flags to prevent Alpine.js component lifecycle
   - Clean up event listeners and global state properly
   - **Data fetching**: Use application-level stores, not component-level fetching
   - **Avoid SPA patterns**: Don't over-engineer with complex state management
5. **Always remove unused code**: After making changes, search for and remove any unused variables, functions, or imports
6. **Test the approach mentally**: Before implementing, think through the full lifecycle and edge cases
7. **Be thorough**: Don't leave sloppy code or half-finished implementations